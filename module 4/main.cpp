/**----------------------------------------------------------------------------
   \file main.cpp
--                                                                           --
--              ECEN 5803 Mastering Embedded System Architecture             --
--                  Project 1 Module 4                                       --
--                Microcontroller Firmware                                   --
--                      main.cpp                                             --
--                                                                           --
-------------------------------------------------------------------------------
--
--  Designed for:  University of Colorado at Boulder
--
--
--  Designed by:  Tim Scherr
--  Revised by:  Abijith Ananda Krishnan and Visalalkshmi Chemudupati
--
-- Version: 2.1
-- Date of current revision:  2017-09-25
-- Target Microcontroller: Freescale MKL25ZVMT4
-- Tools used:  ARM mbed compiler
--              ARM mbed SDK
--              Freescale FRDM-KL25Z Freedom Board
--
--
-- Functional Description:  Main code file generated by mbed, and then
--                           modified to implement a super loop bare metal OS.
--
--      Copyright (c) 2015, 2016 Tim Scherr  All rights reserved.
--
*/

#define MAIN
#include "shared.h"
#undef MAIN

#include <stdint.h>

#define ADC_0                   (0U)
#define CHANNEL_0               (0U)
#define CHANNEL_1               (1U)
#define CHANNEL_2               (2U)
#define LED_ON                  (0U)
#define LED_OFF                 (1U)
#define ADCR_VDD                (65535U)    /*! Maximum value when use 16b resolution */
#define V_BG                    (1000U)     /*! BANDGAP voltage in mV (trim to 1.0V) */
#define V_TEMP25                (716U)      /*! Typical VTEMP25 in mV */
#define M                       (1620U)     /*! Typical slope: (mV x 1000)/oC */
#define STANDARD_TEMP           (25)
#define MAX_FLOW_RATE           (40195U)

extern volatile uint16_t SwTimerIsrCounter;

/* Superloop function prototypes */
uint16_t read_ADC();
void calculate_flow(uint16_t);
void output_420();
void output_pulse();
void output_LCD();
void read_temperature();

Ticker tick;             //  Creates a timer interrupt using mbed methods
/****************      ECEN 5803 add code as indicated   ***************/
// Add code to control red, green and blue LEDs here

DigitalOut greenLED(LED_GREEN);
DigitalOut redLED(LED_RED);
DigitalOut blueLED(LED_BLUE);

AnalogIn vrefl_adc(PTB0);
AnalogIn vortex_adc(PTB1);
AnalogIn temp_adc(PTB2);

PwmOut pwm3(PTE30);
PwmOut pwm4(PTE31);

SPI lcd_out(PTC4, PTC5, PTC6, PTC7); // use 1 MHz, mode 0 SPI

Serial pc(USBTX, USBRX);

/* Variables to also be read in Monitor.cpp */
float frequency = 0.0f;
float flow_rate = 0.0f;
float velocity = 0.0f;
float temperature = 0.0f;

 /**
 * @brief function configures the ADC
 *
 */
bool adc_setup()
{
  ADC0->CFG1   &= ~ADC_CFG1_ADLPC_MASK;  // no low power
  ADC0->CFG1   &= ~ADC_CFG1_ADIV_MASK;   // clock divider = 1
  ADC0->CFG1   |= ADC_CFG1_ADLSMP_MASK;  // long sample time
  ADC0->CFG1   &= ~ADC_CFG1_ADICLK_MASK; // clock source = bus clock
  ADC0->SC3    |= ADC_SC3_ADCO_MASK;     // enable continuous conversions
  ADC0->SC1[0] &= ~ADC_SC1_DIFF_MASK;    // single ended conversion

  // channel-specific (REFSL)
  //    ADC0->CFG1   &= ~ADC_CFG1_MODE_MASK;   // 8-bit, single-ended
  //    ADC0->SC1[0] &= ~ADC_SC1_ADCH_MASK;    // clear input channel select
  //    ADC0->SC1[0] |= 0b11110;               // select REFSL as input

  // channel-specific (vortex)
  // ADC0->CFG1   |= ADC_CFG1_MODE_MASK;    // 16-bit, single-ended
  // ADC0->SC1[0] &= ~ADC_SC1_ADCH_MASK;    // clear input channel select
  // ADC0->SC1[0] |= 0b00001;               // select DAD1 as input

  // channel-specific (temperature)
  ADC0->CFG1   &= ADC_CFG1_MODE_MASK;    // 16-bit, single-ended
  ADC0->SC1[0] &= ~ADC_SC1_ADCH_MASK;    // clear input channel select
  ADC0->SC1[0] |= 0b11010;               // select Temp Sensor as input

  // start ADC calibration
  ADC0->SC2 &= ~ADC_SC2_ADTRG_MASK; // ensure software trigger is set
  ADC0->SC3 |= ADC_SC3_CAL_MASK;    // start the calibration
  while (!((ADC0->SC1[0] & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)); // wait for completion
  if ((ADC0->SC3 &  ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT) {
    return false;
  }

  // get plus-side calibration result
  uint16_t cal_result = 0;
  cal_result += ADC0->CLP0;
  cal_result += ADC0->CLP1;
  cal_result += ADC0->CLP2;
  cal_result += ADC0->CLP3;
  cal_result += ADC0->CLP4;
  cal_result += ADC0->CLPS;
  cal_result /= 2;
  cal_result |= 0x8000;
  ADC0->PG = cal_result;

  // get minus-side calibration result
  cal_result = 0;
  cal_result += ADC0->CLM0;
  cal_result += ADC0->CLM1;
  cal_result += ADC0->CLM2;
  cal_result += ADC0->CLM3;
  cal_result += ADC0->CLM4;
  cal_result += ADC0->CLMS;
  cal_result /= 2;
  cal_result |= 0x8000;
  ADC0->MG= cal_result;

  return true;
}

void flip()
{
  greenLED = !greenLED;
}

 /**
 * @brief function runs the super loop
 */
int main()
{
  /* Initialize LEDs */
  greenLED = 0;
  redLED = 0;
  blueLED = 0;

  /****************      ECEN 5803 add code as indicated   ***************/
  //  Add code to call timer0 function every 100 uS

  pc.printf("Hello World!\n");
  uint32_t  count = 0;

  // initialize serial buffer pointers
  rx_in_ptr =  rx_buf; /* pointer to the receive in data */
  rx_out_ptr = rx_buf; /* pointer to the receive out data*/
  tx_in_ptr =  tx_buf; /* pointer to the transmit in data*/
  tx_out_ptr = tx_buf; /*pointer to the transmit out */

  // Print the initial banner
  pc.printf("\r\nHello World!\n\n\r");

  /****************      ECEN 5803 add code as indicated   ***************/
  // uncomment this section after adding monitor code.
  UART_direct_msg_put("\r\nSystem Reset\r\nCode ver. ");
  UART_direct_msg_put( CODE_VERSION );
  UART_direct_msg_put("\r\n");
  UART_direct_msg_put( COPYRIGHT );
  UART_direct_msg_put("\r\n");

  set_display_mode();

  uint16_t measurement;

  while(1) {     // Cyclical Executive Loop
    count++;                  // counts the number of times through the loop
    //      __enable_interrupts();
    //      __clear_watchdog_timer();

    serial();            // Polls the serial port
    chk_UART_msg();     // checks for a serial port message received
    monitor();           // Sends serial port output messages depending
    //  on commands received and display mode

    /****************      ECEN 5803 add code as indicated   ***************/

    measurement = read_ADC();
    calculate_flow(measurement);
    output_420();
    output_pulse();
    output_LCD();
    if ((SwTimerIsrCounter & 0x1FFF) > 0x0FFF) {
      flip();  // Toggle Green LED
    }
  }
}

/* In this simulation: draw one ADC value from the provided sample dataset */
/* In real life: perform one ADC measurement */
 /**
 * @brief function reads the ADC
 */
uint16_t read_ADC()
{
  return 0;
}

/* For use in zero-crossing algorithm */
#define UINT16_MAX 65535
#define UINT16_HALF (UINT16_MAX / 2)
#define OFFSET_ZERO 32767

/* Given the next measurement data point, calculate the estimated flow rate */
/* This function has memory */
 /**
 * @brief function calculates the flow
 */
void calculate_flow(uint16_t measurement)
{
  /* Declare static variables */
  static uint16_t last_measurement = 0;
  static uint16_t zero_crossings = 0;
  static uint16_t data_points = 0;

  data_points++;

  /* Derived constants - ideally optimized away at compilation */
  float diameter_m = 0.0127f; /* Bluff body diameter in meters */
  float diameter_in = 0.5f; /* Bluff body diameter in inches */
  float pid_m = 0.07366f; /* Pipe inner diameter in meters */
  float pid_in = 2.9f; /* Pipe inner diameter in inches */
  float timestep = 0.0001f; /* 100us sample time */
  float viscosity = 2.4f * 0.00001f * pow(10.0f, 247.8f / (temperature - 140.0f)); /* units kg/m^3 */
  float rho = 1000.0f * (1.0f - (temperature + 288.9414f) / (508929.2f * (temperature + 68.12963f)) * pow(temperature - 3.9863f, 2.0f)); /* units kg/(m*s) */

  /* Read temperature */
  read_temperature();

  /* First: calculate frequency estimate from measurement */
  if ((measurement > OFFSET_ZERO && last_measurement < OFFSET_ZERO) || (measurement < OFFSET_ZERO && last_measurement > OFFSET_ZERO)) {
    /* Zero crossing */
    zero_crossings++;
  }
  last_measurement = measurement;
  frequency = (float)(zero_crossings) / ((float)(data_points) * 4.0f / 3.0f * timestep);

  /* Next: calculate velocity from frequency estimate */
  velocity = 1.0f / (diameter_m * rho) * 0.00000111051f * (3355000.0f * diameter_m * diameter_m * frequency * rho + 6702921.0f * viscosity);

  /* Next: calculate flow rate from velocity */
  flow_rate = velocity * 3.28084f * pid_in * pid_in * 2.45f; /* units of gallons per minute */
}

 /**
 * @brief function outputs to the 4-20 mA loop with pulse width proportional to flow rate
 */
void output_420()
{
  pwm3.pulsewidth(flow_rate/MAX_FLOW_RATE);
}


 /**
 * @brief function outputs pulses at rate proportional to frequency
 */
void output_pulse()
{
  pwm4.period_us((int) 1/frequency);
}

void output_LCD()
{
  lcd_out.write((int) flow_rate);
}

void read_temperature() {
  float Vtemp = (float)(temp_adc);
  /* Begin code from "Temperature Sensor for the HCS08 Microcontroller Family" app note document */
  Vtemp = Vtemp * 0.0029296875f;
  if (Vtemp >= .7012f) {
    temperature = 25.0f - ((Vtemp - .7012f) / .001646f);
  } else {
    temperature = 25.0f - ((Vtemp - .7012f) / .001749f);
  }
  /* End code from "Temperature Sensor for the HCS08 Microcontroller Family" app note document */
  temperature += 274.15f; /* Convert from Celsius to Kelvin */
}